// fs.c â€” simple in-memory filesystem for RISC-V OS
// embeds demo text files and one loadable ELF (userprog.elf)

#include "uart.h"
#include "fs.h"
#include <stdint.h>
#include <stddef.h>

// symbols from userprog_bin.o (generated by objcopy)
extern const uint8_t _binary_userprog_elf_start[];
extern const uint8_t _binary_userprog_elf_end[];

typedef struct {
    const char *name;
    const uint8_t *data;
    int is_binary;   // 0 = text (for cat), 1 = binary (ELF)
} File;

// text file contents
static const char readme_txt[] =
    "This is the RISC-V OS demo filesystem.\n";

static const char hello_txt[] =
    "Hello from your in-memory filesystem!\n";

static const char manual_txt[] =
    "Commands: help, ls, cat <file>, run <task>, load <file>\n";

// file table (mix of text and binary)
static File files[] = {
    { "README.md",   (const uint8_t *)readme_txt,   0 },
    { "hello.txt",   (const uint8_t *)hello_txt,    0 },
    { "manual.txt",  (const uint8_t *)manual_txt,   0 },

    // ELF file that the loader can load
    { "userprog.elf", _binary_userprog_elf_start,   1 },
};

#define FILE_COUNT ((int)(sizeof(files) / sizeof(files[0])))

// simple string equality
static int str_eq(const char *a, const char *b) {
    while (*a && *b) {
        if (*a != *b) return 0;
        a++; b++;
    }
    return (*a == '\0' && *b == '\0');
}

// compute length of a C string (for text files)
static size_t cstr_len(const char *s) {
    size_t n = 0;
    while (s[n] != '\0') n++;
    return n;
}

void fs_init(void) {
    uart_puts("[FS] initialized with demo files.\n");
}

void fs_list(void) {
    uart_puts("Files:\n");
    for (int i = 0; i < FILE_COUNT; i++) {
        uart_puts("  ");
        uart_puts(files[i].name);
        uart_puts("\n");
    }
}

void fs_cat(const char *filename) {
    for (int i = 0; i < FILE_COUNT; i++) {
        if (str_eq(filename, files[i].name)) {
            if (files[i].is_binary) {
                uart_puts("Cannot cat binary file.\n");
                return;
            }
            const char *text = (const char *)files[i].data;
            for (size_t j = 0; text[j] != '\0'; j++) {
                uart_putc(text[j]);
            }
            return;
        }
    }
    uart_puts("No such file.\n");
}

// fs_get_file: returns pointer+size for text files and binary ELF.
//   Returns 0 on success, -1 on not found.
int fs_get_file(const char *name, const uint8_t **data_out, size_t *size_out) {
    for (int i = 0; i < FILE_COUNT; ++i) {
        if (!str_eq(name, files[i].name)) continue;

        *data_out = files[i].data;

        if (files[i].is_binary) {
            // currently only userprog.elf is binary
            if (files[i].data == _binary_userprog_elf_start) {
                *size_out = (size_t)(_binary_userprog_elf_end -
                                     _binary_userprog_elf_start);
            } else {
                // fallback, in case you add other binaries later
                *size_out = 0;
            }
        } else {
            *size_out = cstr_len((const char *)files[i].data);
        }

        return 0;
    }
    return -1;
}
